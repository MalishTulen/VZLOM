# Взлом программы

## Введение
Данный проект является учебным. Работа производилась в операционной системе DOS из-за того, что в ней можно работать на очень низком уровне. В данной задаче было предложено разбиться на пары, написать crackme с двумя уязвимостями, обменяться файлами и, в свою очередь, взломать crackme оппонента и написать программу с графическим интерфейсом, которая бы меняла байты в предоставленной программе, таким образом, чтобы программа
выводила сообщение о правильности ввода пароля при неправильном вводе.
## 1.Мои уязвимости

### • Легкая уязвимость
Буфер ввода расположен перед строкой паролем, с которой сверяется компаратор, но максимальная длинна буфера заданна ошибочно, больше нужного, то есть, буфер при переполнении перезапишет пароль.
<details><summary>Инициализация буфера под пароль</summary>

```c
USERS_INPUT     db 15                   ;max buffer length
                db 0                    ;actual buffer length
                db 10 dup (" ")
PASSWORD        db 'elda'
```
</details>

\
Это позволяет взломать программу ничего не изменяя в бинарном коде: достаточно заполнить буфер одинаковыми символами ( функция сравнения паролей будет проверять одинаковые символы ).

<details><summary>Пример взлома через легкую уязвимость</summary>

![alt text](image.png)
</details>

### • Сложная уязвимость
Буфер в моей программе при вводе имеет неограниченную длинну, это позволяет при вводе с клавиатуры переполнить буфер, дойти до стека, и вставить в него адрес return на благополучный исход.


## 2. Взлом оппонента

### Исходные данные

Программа представляла собой исполняемый файл с расширением .com, который работал в среде DOS. Для анализа использовались следующие инструменты:

**•  Дизассемблер+отладчик(TurboDebugger)**: для анализа маштнного кода и получения ассемблерного листинга, а также пошагового выполнения программы и анализа состояния регистров и памяти.

**• Hex-редактор(Hex-editor Microsoft)**: для создания файлов для взлома программы.

Дизассемблируя код была замечена первая уязвимость: буфер ввода находится прямо внутри кода, перед ним стоит обходящий его джамп. То есть можно переполнить буфер, заменив следующую за вызовом прерывания команду на джамп, на часть кода, отвечающую за правильный пароль.

<details><summary>Пример взлома через легкую уязвимость</summary>

![alt text](image-5.png)
</details>

\
Вторая, более сложная уязвимость оппонента, заключается в следующем: при вводе и считывании пароля нигде не ограничевается количество введенных символов.
Функция DOS 3f принимает на вход дескриптор файла(bx), количество байтов для возможного ввода(cx) и адрес буфера(dx). Сделав cx = 0xFFFF мы, по факту, сделали количество введенных байтов размером с сегмент.

<details><summary>Считывание ввода пользователя</summary>

```c
request_pwd proc

            mov     ah, 3fh
            xor     bx, bx
            mov     cx, 0FFFFh
            mov     dx, offset buffer
            int     21h

            ret
            endp
```

</details>

\
Это дает нам возможность переполнить код и записать в стек адрес команды, дающей нам доступ. Для этого мы пишем программу которая сначла заполнит основной код FFFF - 0189h байт(FFFF - количество байт в сегменте, 189 - адрес буфера),
<details><summary>Расположение адреса в пямять</summary>

![alt text](image-8.png)
</details>

\
 и затем пишем адрес возврата, тк сразу после считывания вызывается **ret**, то он прыгнет по нужному адресу и даст доступ.

<details><summary>Пример взлома через сложную уязвимость</summary>

![alt text](image-6.png)
</details>

\
Также есть еще возможность для взлома программы пользуясь специальной программой - кряк. Данная программа изменяет исходный код таким образом, чтобы программа для взлома исполняла тот код, который нам требуется. Программа представляет из себя графическое приложение. При запуске появляется симуляция, после завершения которой входной файл крякается.

Изменив байт с 1 на 0, у нас получается отрицание сравнения, т е при вводе любого пароля программа даст доступ

<details><summary>Команда, осуществляющая замену байта</summary>

```c
const size_t CMD_ADDR  = 0x2E;
const char NEW_COMMAND = 0x00;

int byte_changer ( FILE* ptr_file )
{
    fseek( ptr_file, CMD_ADDR, SEEK_SET );
    fwrite( &NEW_COMMAND, 1, 1, ptr_file );

    return 0;
}
```

</details>
<details><summary>Пример взлома через бинарный патч</summary>

![alt text](image-4.png)
</details>

## ИТОГ
В результате анализа программы были найдены и успешно эксплуатированы две уязвимости связанные с переполнением входного буфера. Данная работа - отличный пример того, что всегда важно проверять входные данные, дабы избежать подобных атак.
